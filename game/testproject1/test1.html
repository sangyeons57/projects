<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>test1</title>
		<style>
			button{width: 80px; height: 40px;}
			hr.one{border: none; border: 2px dashed black;}
		</style>
	</head>

	<body id="body">
		<canvas id="canvas" width="210" height="210"></canvas>

		<!--script-->
		<script src="https://code.jquery.com/jquery-2.1.0.js"></script>


		<script>
			class Gamesetting{

				canvas
				ctx
				place
				blocksize
				screen_x 
				screen_y
				now_screen_x
				now_screen_y
				constructor(){
					this.canvas = document.getElementById("canvas");
					this.ctx = this.canvas.getContext("2d");

					this.place = [];

					this.blocksize = 10;

					this.screen_x = 0
					this.screen_y = 0

					this.now_screen_x = 0
					this.now_screen_y = 0
				}

				makemap(){		//맵만들기
					for(let i = 0; i <= 99; i++){
						let place_line = []
						for(let li = 0; li<=99; li++){
							if(li%2===0){
								place_line.push("#04B404")
							} else {
								place_line.push("#088A08")

							}
						}
						this.place.push(place_line)
					}

				// list 형태 list[x][y]
				//		0	1	2
				//	  0 l	l	l
				//	=>1 i	i	i
				//	  2 s	s	s
				//	  3 t	t	t
				}

				bulid_map(){
					for (let i = 0; i<100;i++){
						for (let li = 1 ; li<10;li++){
							this.place[i][li] = "gray"
						}
					}
					for(let i = 0; i<10;i++){
						for (let li = 10 ; li<100;li++){
							this.place[i][li]= "gray"
						}
					}
					for (let i = 91; i <= 99;i++){
						for (let li in this.place[1]){
							this.place[i][li]= "Gray"
						}
					}
					for(let i = 10; i<91;i++){
						for(let li =91; li<100;li++){
							this.place[i][li]="gray"
						}
					}
					this.place[10][80]
				}


				move_direction(){				//방향키중 뭘눌렀는지 확인
					$(document).keydown((event) => { 
						const code = {38:"up", 40:"down", 39:"right",37:"left"}
						let direction = code[event.keyCode]
						if (direction ==="up"){
							this.screen_y -= 1
							if (this.screen_y<0){
								this.screen_y+=1
							}
						} else if (direction ==="down"){
							this.screen_y += 1
							if (this.screen_y>=81){
								this.screen_y-=1
							}
						} else if (direction ==="right"){
							this.screen_x += 1
							if (this.screen_x>=81){
								this.screen_x-=1
							}
						} else if (direction ==="left"){
							this.screen_x -= 1
							if (this.screen_x<0){
								this.screen_x+=1
							}
						}
						console.log(this.screen_x,this.screen_y)
					})
				}

				m_move_direction(){
					document.getElementById("canvas").addEventListener('touchstart',(e)=>{
						let clientx =Math.round(e.touches[0].clientX)
						let clienty =Math.round(e.touches[0].clientY)
						console.log(clientx,clienty)
						if (clientx>160){
							console.log("1")
							this.screen_x += 1
							if (this.screen_x>=81){
								this.screen_x-=1
							}
						} else if(clientx<70){
							console.log("2")
							this.screen_x -= 1
							if (this.screen_x<0){
								this.screen_x+=1
							}
						} else if(clienty>160){
							this.screen_y += 1
							if (this.screen_y>=81){
								this.screen_y-=1
							}
						} else if(clienty<70){
							this.screen_y -= 1
							if (this.screen_y<0){
								this.screen_y+=1
							}
						}
					})
				}

				draw_backgroud(){
					const blocksize = this.blocksize
					const ctx = this.ctx
					const canvas = document.getElementById("canvas")
						ctx.fillRect(0,0,blocksize,canvas.height)
						ctx.fillRect(0,canvas.height-blocksize,canvas.width,blocksize)
						ctx.fillRect(0,0,canvas.width,blocksize)
						ctx.fillRect(canvas.width-blocksize,0,blocksize,canvas.height)
				}


				enter(direction){		//그리기
					setInterval(() => {
						const ctx = this.ctx
						for (var x=1; x<200/this.blocksize; x++){
							for (var y=1; y<200/this.blocksize; y++){
								this.color(x,y)
								ctx.fillRect(x*this.blocksize,y*this.blocksize,this.blocksize,this.blocksize)
							}
						}
						ctx.fillStyle = "black"
						ctx.fillRect(10*this.blocksize,10*this.blocksize,this.blocksize,this.blocksize)
					}, 100);
				}

				color(x,y){
					this.now_screen_x = this.screen_x
					this.now_screen_y = this.screen_y
					const ctx = this.ctx
					let color = this.place[this.now_screen_x+x][this.now_screen_y+y]

					ctx.fillStyle = color
				//	console.log(this.place[this.now_screen_x+x][this.now_screen_y+y])
				//	console.log(this.now_screen_x,this.now_screen_y)
				}

				blue_thing_1(){
					const ctx = this.ctx
					let blue_thing_1_x = 17
					let blue_thing_1_y = 17
					let blocksize = this.blocksize
					let backcolor = this.place[blue_thing_1_x][blue_thing_1_y]
					let blue_thing_1_x_past = 0 
					let blue_thing_1_y_past = 0 
					let direction = 0
					let blue_speed = 0
					setInterval(() => {
						direction = Math.ceil(Math.random()*4)

					},400)
					setInterval(() => {
						blue_thing_1_y_past = blue_thing_1_y
						blue_thing_1_x_past = blue_thing_1_x
						if (direction === 1){
							blue_thing_1_x+=1
							if(blue_thing_1_x>80){
								blue_thing_1_x-=1
							}
						}else if (direction === 2){
							blue_thing_1_x-=1
							if(blue_thing_1_x<10){
								blue_thing_1_x+=1
							}
						}else if (direction === 3){
							blue_thing_1_y += 1
							if(blue_thing_1_y>80){
								blue_thing_1_y-=1
							}
						}else if (direction === 4){
							blue_thing_1_y -= 1
							if(blue_thing_1_y<10){
								blue_thing_1_y+=1
							}
						}
						this.place[blue_thing_1_x_past][blue_thing_1_y_past] = backcolor
						backcolor = this.place[blue_thing_1_x][blue_thing_1_y]
						this.place[blue_thing_1_x][blue_thing_1_y] ="blue"
					},100)
				}


			}
			// 해야하는것
			// x y 값을 만들고 움직일때마다 1씩  빼고 더하고
			//	!함수 : 해당 위차의 색 받기

			const gamesetting = new Gamesetting
			function main(){
				gamesetting.makemap()
				gamesetting.move_direction()
				gamesetting.draw_backgroud()
				gamesetting.enter()
				gamesetting.bulid_map()
				gamesetting.blue_thing_1()
				gamesetting.m_move_direction()
			}
			main()

		</script>


		<!--script-->

		<hr class="one">
		<button type="button" onclick="location.href='index.html'">back</button>

	</body>
</html>
